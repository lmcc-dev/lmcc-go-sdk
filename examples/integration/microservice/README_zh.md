# 微服务集成示例

[English Version](README.md)

此示例展示了使用lmcc-go-sdk包的综合微服务实现。它演示了如何构建一个具有可观察性功能、健康检查和适当错误处理的生产就绪微服务。

## 功能特性

- **用户服务**: 用户管理的完整CRUD操作
- **gRPC风格服务结构**: 清晰的服务层架构
- **HTTP REST API**: 用户操作的RESTful端点
- **健康检查**: 全面的健康监控
- **指标收集**: 请求计数、错误跟踪和延迟测量
- **分布式链路追踪**: 跨服务层的请求追踪
- **数据库层**: 模拟数据库操作与适当的错误处理
- **配置管理**: 基于YAML的配置，带有默认值
- **结构化日志**: JSON和文本日志格式，支持链路关联

## 服务架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   HTTP服务器    │    │   用户服务      │    │   数据库层      │
│                 │    │                 │    │                 │
│ • REST API      │───▶│ • 业务逻辑      │───▶│ • 数据存储      │
│ • 健康检查      │    │ • 验证逻辑      │    │ • 查询逻辑      │
│ • 指标收集      │    │ • 错误处理      │    │ • 事务管理      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   指标服务      │    │   链路追踪服务  │    │   日志服务      │
│                 │    │                 │    │                 │
│ • 请求计数      │    │ • 追踪ID生成    │    │ • 结构化日志    │
│ • 错误率        │    │ • 上下文传递    │    │ • 链路关联      │
│ • 延迟统计      │    │ • 跨度跟踪      │    │ • 多级别日志    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 组件介绍

### 用户服务
- **GetUser**: 通过ID检索用户，包含验证和错误处理
- **CreateUser**: 创建新用户，包含冲突检测
- **请求/响应模型**: 结构化数据传输对象

### 可观察性堆栈
- **MetricsCollector**: 记录请求、错误和延迟统计
- **TracingService**: 生成并传播跨操作的追踪ID
- **HealthChecker**: 多层健康监控（数据库、内存、响应时间）

### HTTP层
- **REST API端点**: 
  - `GET /api/users/{id}` - 通过ID获取用户
  - `POST /api/users` - 创建新用户
  - `GET /health` - 健康检查
  - `GET /metrics` - 服务指标

## 配置

服务支持带有合理默认值的YAML配置：

```yaml
service:
  name: "user-service"
  version: "v1.0.0"
  port: 50051

http:
  port: 8080
  health_check_path: "/health"
  metrics_path: "/metrics"

database:
  host: "localhost"
  port: 5432
  name: "userdb"
  max_conns: 10
  conn_timeout: 5

logging:
  level: "info"
  format: "json"
  output_paths: ["stdout"]

observability:
  tracing_enabled: true
  metrics_enabled: true
  service_mesh: "istio"
```

## 使用方法

### 运行示例

```bash
# 导航到微服务示例目录
cd examples/integration/microservice

# 运行微服务
go run main.go
```

### 预期输出

示例演示了：

1. **服务初始化**: 配置加载和组件设置
2. **用户操作**: 带验证和错误处理的CRUD操作
3. **健康监控**: 数据库、内存和响应时间检查
4. **指标收集**: 请求计数和性能跟踪
5. **HTTP API测试**: REST端点验证
6. **分布式链路追踪**: 跨服务层的请求关联

### 示例输出

```
=== 微服务集成示例 ===
此示例演示了带有gRPC、可观察性和健康检查的微服务。

=== 运行微服务演示 ===

1. 测试用户操作:
   ✅ 获取用户成功: alice (trace_20241123_12345)
   ✅ 获取不存在用户正确失败: user not found
   ✅ 创建用户成功: user_1700123456 (trace_20241123_12346)

2. 测试健康检查:
   服务状态: healthy
   时间戳: 2024-11-23T10:15:30Z

3. 服务指标:
   get_user: 2 requests
   create_user: 1 requests

启动HTTP服务器进行额外测试...
HTTP服务器运行在端口 8080
可用端点:
  GET  http://localhost:8080/health
  GET  http://localhost:8080/metrics
  GET  http://localhost:8080/api/users/user_001

=== 运行HTTP端点测试 ===

测试健康检查端点:
   ✅ 健康检查成功: 200
测试指标端点:
   ✅ 指标端点成功: 200
测试用户API:
   ✅ 用户API成功: 200

=== HTTP测试完成 ===
=== 示例成功完成 ===
```

## 关键学习要点

### 1. 服务层架构
- HTTP、业务逻辑和数据层的清晰分离
- 组件组合的依赖注入模式
- 可测试性的基于接口设计

### 2. 可观察性集成
- **指标**: 请求计数、错误分类、延迟跟踪
- **链路追踪**: 跨服务边界的请求关联
- **日志**: 带追踪上下文的结构化日志

### 3. 错误处理模式
- 带上下文的自定义错误类型
- 跨服务层的错误传播
- 对客户端友好的优雅错误响应

### 4. 配置管理
- 带结构标签的基于YAML配置
- 默认值处理
- 环境特定覆盖

### 5. 健康检查设计
- 多层健康监控
- 依赖健康验证
- 性能阈值验证

## 生产环境考虑

此示例演示了适用于生产微服务的模式：

- **配置**: 带默认值的外部化配置
- **日志**: 带关联ID的结构化日志
- **监控**: 健康检查和指标收集
- **错误处理**: 全面的错误分类和处理
- **性能**: 延迟跟踪和优化机会
- **可维护性**: 关注点分离的清晰架构

## 测试

示例包含全面的测试场景：

- 成功操作
- 错误条件（验证、未找到）
- 健康检查验证
- HTTP端点验证
- 指标收集验证

## 集成模式

此微服务示例可以通过以下方式扩展：

- **数据库集成**: 用真实持久化替换模拟数据库
- **消息队列**: 添加异步通信模式
- **服务发现**: 与服务网格或发现系统集成
- **API网关**: 添加认证和速率限制
- **容器部署**: Docker和Kubernetes配置

要了解更高级的模式，请查看此目录中的其他集成示例。 